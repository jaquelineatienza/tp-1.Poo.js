**¿Qué diferencias, ventajas y desventajas encontrás entre usar funciones constructoras con prototype y usar class?**
Las funciones contrusctoras con prototype tienen un enfoque mas antiguo de js lo que les da compatibilidad con versiones antiguas de ES5 y un control mas bajo del nivel sobre el cual se manipula el prototype; sin embargo su sintaxis es menos intuitiva y require mas configuraciones manuales. Por otro lado las class fueron introducidas en ES6, internamente funcionan igual que las funciones contructoras pero con una sintaxis mas clara y ordenada, herencia simplificada; su principal desventaja es que requieren un entorno compatible o transpilacion si se quiere soporte en navegadores antiguos
**¿Cuáles son las ventajas de usar getters y setters?**
Los getters y setters permiten controlar y personalizar el acceso a las propiedades de un objeto, lo que facilita encapsular la lógica interna, validar y filtrar datos antes de asignarlos, ejecutar código adicional al leer o modificar un valor, y definir propiedades calculadas que no necesitan almacenarse físicamente; además, mantienen una interfaz limpia, ya que se usan como si fueran atributos normales, lo que mejora la legibilidad y reduce el acoplamiento del código.

**¿Qué problemas pueden surgir al modificar prototipos nativos como String?**
Modificar prototipos nativos como String.prototype puede causar conflictos si el estándar de JavaScript implementa en el futuro un método con el mismo nombre ya que pueden romper la compatibilidad con librerías que dependen del comportamiento original y afectar globalmente a todos los objetos de ese tipo incluso en partes del código que no lo necesitan, y degradar el rendimiento.

**Teniendo en cuenta un objeto personPrototype que contiene un método greet, ¿qué diferencias encontrás entre asignar ese método directamente al prototype de una función constructora o usar Object.assign?**
Si un personPrototype contiene un método como greet, asignarlo directamente al prototype de una función constructora copia únicamente ese método, lo que obtorga un control más preciso y evita sobrescribir propiedades no deseadas. En cambio, usar Object.assign permite copiar en bloque todos los métodos y propiedades de personPrototype al prototype de la función constructora de forma rápida y concisa, pero se corre con el riesgo de sobrescribir métodos existentes.
